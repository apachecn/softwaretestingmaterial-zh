# 100 多种软件测试——终极清单

> 原文:[https://www . software testing material . com/types-of-software-testing/](https://www.softwaretestingmaterial.com/types-of-software-testing/)

在这篇文章中，我想一次提到几乎所有的[软件测试](https://www.softwaretestingmaterial.com/manual-testing-tutorial/)类型。学习软件测试的一个挑战是，行业中有许多术语，并且这些术语经常使用不一致。虽然对于所有的测试术语没有普遍接受的定义，但我认为一个好的来源是参考 [ISTQB 认证测试员基础水平大纲。](http://www.istqb.org/downloads/send/2-foundation-level-documents/3-foundation-level-syllabus-2011.html4)

[![Types of Software Testing](../Images/127fbf048dbcd236fd6d91899c8eff67.png)T2】](https://www.softwaretestingmaterial.com/wp-content/uploads/2015/12/100-Types-of-Software-Testing.png)

## **100 多种软件测试类型的最终列表**

在进入实际的 post 100+软件测试类型之前，我想先从软件测试开始。

**软件测试:**这是一个评估软件应用程序功能的过程，旨在发现开发的软件是否满足指定的要求，并识别缺陷，以确保产品无缺陷，从而生产出高质量的产品。阅读更多关于[软件测试定义&方法](https://www.softwaretestingmaterial.com/software-testing/)的内容。

**2。非功能性测试**:简单来说，系统表现的有多好就是非功能性测试。非功能测试指的是软件的各个方面，如性能、负载、压力、可伸缩性、安全性、兼容性等。的主要目的是改善用户体验，提高系统响应请求的速度。

**3。手动测试**:手动测试是手动测试软件以发现缺陷的过程。测试人员应该站在最终用户的角度，确保所有的功能都像需求文档中提到的那样工作。在这个过程中，测试人员执行[测试用例](https://www.softwaretestingmaterial.com/test-case-template-with-explanation/)并手动生成报告，而不使用任何自动化工具。

**4。自动化测试**:自动化测试是使用自动化工具测试软件以发现缺陷的过程。在这个过程中，执行测试脚本和生成结果是由自动化工具自动执行的。一些最流行的自动化测试工具有惠普 QTP/UFT、[、Selenium WebDriver](https://www.softwaretestingmaterial.com/install-selenium-webdriver/) 等。,

了解手动&和自动测试的区别…

**5。黑盒测试**:黑盒测试是一种[软件测试](https://www.softwaretestingmaterial.com/software-testing/)方法，测试人员在不查看内部代码结构的情况下评估被测软件的功能。这可以应用于软件测试的每一个层次，比如单元、集成、系统和验收测试。

> [在这里阅读更多关于黑盒测试的内容](https://www.softwaretestingmaterial.com/black-box-and-white-box-testing/) …

**6。玻璃盒测试:**玻璃盒测试是一种扫描程序结构，然后根据程序的流程和逻辑创建测试数据的测试方法论。这种类型的测试主要通过利用内部编程逻辑来选择适当的测试数据并消除设计错误来完成。

玻璃盒测试被称为开放盒测试、逻辑驱动测试、路径驱动测试或透明盒测试。玻璃盒测试的技术有路径覆盖、分支覆盖和语句覆盖。

7 .**。白盒测试**:白盒测试又称玻璃盒、透明盒、结构测试。它基于应用程序内部代码结构。在白盒测试中，系统的内部视角以及编程技巧被用来设计测试用例。这种测试通常在单元级完成。

[点击此处了解更多详情。](https://www.softwaretestingmaterial.com/black-box-and-white-box-testing/)

**8。基于规格的测试**:基于规格的测试类似于行为驱动测试和黑盒测试。测试人员通过将应用程序视为黑盒来执行测试，他们对程序的内部逻辑或流程没有任何了解。因此，简而言之，测试人员更关心应用程序的行为。

基于规范的测试包括非功能性测试和功能性测试。规范可以是原型、书面文档、一组用例的形式。它被认为是构建测试数据的参考。基于规格的测试技术有决策表、等价划分、边界值分析和状态转换。

**9。基于结构的测试**:

基于结构的测试需要程序逻辑和流程的技术知识。这种类型的测试确保有最大的测试覆盖率和测试设计是正确的。在项目开发的初始阶段采用基于结构的测试来确定所需的测试数量。

基于结构的测试也有助于创建一些额外的测试用例，以增加测试覆盖率，不同于预先存在的测试用例。因此它在测试中实现了更大的深度。基于结构的测试技术有路径测试、条件测试、多条件测试、决策测试和语句测试。

10。灰盒测试:灰盒是白盒和黑盒测试的结合。从事这类测试的测试人员需要访问设计文档。这有助于在这个过程中创建更好的测试用例。

**11。单元测试**:单元测试也叫模块测试或组件测试。这样做是为了检查源代码的单个单元或模块是否工作正常。它是由开发者在开发者的环境中完成的。

**12。组件测试:**指单元测试

13。模块测试:参考单元测试

**14。集成测试**:集成测试是测试两个软件单元之间接口的过程。集成测试由多种方法完成，如大爆炸方法、自顶向下方法、自底向上方法和混合集成方法。

> [集成测试完整指南](https://www.softwaretestingmaterial.com/integration-testing/)

15。系统测试:测试完全集成的应用程序，以评估系统是否符合其指定的要求，这被称为系统测试，也称为端到端测试。验证完整的系统，以确保应用程序是否按预期工作。

16。验收测试:也称生产前测试。这由最终用户和测试人员一起完成，以验证应用程序的功能。验收测试成功后。为确定应用程序是否按照要求开发而进行的正式测试。它允许客户接受或拒绝申请。验收测试的类型有阿尔法、贝塔&伽马。

**17。大爆炸集成测试**:将所有模块组合一次，在完成单个模块测试后验证功能。

自顶向下和自底向上是通过使用被称为存根和驱动器的虚拟模块来实现的。这些存根和驱动程序用于替代丢失的组件，以模拟模块之间的数据通信。

18。自顶向下集成测试:测试自顶向下进行。首先测试高级模块，然后测试低级模块，最后将低级模块集成到高级模块，以确保系统按预期工作。如果一个模块没有准备好进行集成测试，存根就被用作临时模块。

**19。自底向上的集成测试**:这是自顶向下方法的一个补充。测试自下而上进行。首先测试最低级别的模块，然后测试高级别模块，最后将高级别模块集成到低级别，以确保系统按预期工作。驱动程序被用作集成测试的临时模块。

20。混合集成测试:混合集成测试是自顶向下和自底向上集成测试的结合。

**21。Alpha 测试** : Alpha 测试由内部开发人员(开发软件的人)和测试人员完成。有时 alpha 测试是由客户或外包团队在开发人员或测试人员在场的情况下完成的。

**22。Beta 测试** : Beta 测试由有限数量的最终用户在交付前完成。通常，它是在客户的地方完成的。

**23。Gamma 测试:** Gamma 测试是在软件准备好发布特定需求时进行的。它是在客户那里完成的。它是通过跳过所有内部测试活动直接完成的。

**24。等价划分测试**:等价划分也称为等价类划分。在等价划分中，软件或系统的输入被划分为预期表现出相似行为的组，因此它们很可能以相同的方式被提出。因此从每组中选择一个输入来设计测试用例。

阅读更多关于等价划分测试技术的内容

**25。边界值分析测试**:边界值分析(BVA)是基于测试有效和无效分区的边界值。每个等价划分边缘的行为比划分内的行为更有可能是不正确的，所以边界是测试可能产生缺陷的区域。每个分区都有其最大值和最小值，这些最大值和最小值是分区的边界值。有效分区的边界值是有效的边界值。类似地，无效分区的边界值也是无效的边界值。

[阅读更多关于边界值分析测试技术的内容](https://www.softwaretestingmaterial.com/boundary-value-analysis-testing-technique/) …

**26。决策表测试**:决策表又名因果表。这种测试技术适用于输入之间有逻辑关系的功能(if-else 逻辑)。在决策表技术中，我们处理输入的组合。为了用决策表识别测试用例，我们考虑条件和动作。我们把条件作为输入，把行动作为输出。

[阅读更多关于决策表测试技术的信息](https://www.softwaretestingmaterial.com/decision-table-test-design-technique/) …

**27。因果图测试:**因果图测试是一种测试用例开发方法，它从一组需求开始，然后确定用最少的时间和成本实现最大覆盖所需的测试用例的最佳数量。

**28。状态转换测试**:使用状态转换测试，我们从需要测试不同系统转换的应用程序中挑选测试用例。当应用程序对相同的输入给出不同的输出时，我们可以应用这一点，这取决于在早期状态下发生了什么。

[阅读更多关于状态转换测试设计技术的信息](https://www.softwaretestingmaterial.com/state-transition-test-design-technique/) …

**29。** **穷举测试:**使用所有有效和无效的输入和前提条件测试所有功能被称为穷举测试。

三十岁。早期测试:在 SDLC 早期阶段检测到的缺陷修复起来更便宜。因此，进行早期测试降低了修复缺陷的成本。

31。用例测试:用例测试是在用例文档的帮助下进行的。这样做是为了识别测试场景来测试端到端测试

32。场景测试:场景测试是一种基于场景的软件测试技术。它包括将业务需求转换为测试场景，以便更好地理解和实现端到端的测试。一个设计良好的场景应该是激励性的、可信的、复杂的，并且其结果易于评估。

33。文档测试:进行文档测试是为了验证文档化的工件，比如需求、测试计划、跟踪矩阵、测试用例。

34。语句覆盖测试:语句覆盖测试是一种白盒测试技术，用于验证代码中的每一条语句是否至少执行一次。

35。决策覆盖测试/分支覆盖测试:决策覆盖或分支覆盖测试是一种白盒测试技术，用于验证每个可能的分支至少执行一次。

36。路径测试:路径覆盖测试是一种白盒测试技术，用于验证程序的所有路径至少执行一次。

37。变异测试:变异测试是白盒测试的一种，是改变(变异)源代码中的某些语句，验证测试是否能发现错误。

38。循环测试:循环测试是一种白盒测试技术，用于验证不同类型的循环，如简单循环、嵌套循环、级联循环和非结构化循环。

39。性能测试:这种测试确定或验证被测系统或应用程序的速度、可伸缩性和/或稳定性特征。性能与实现满足项目或产品性能目标的响应时间、吞吐量和资源利用率水平有关。

40。负载测试:验证系统/应用程序能够处理预期数量的事务，并验证系统/应用程序在正常和峰值负载条件下的行为。

41。压力测试:验证负载增加超过设计预期时系统的行为。

**42。浸泡测试**:长时间在高负载下运行系统以识别性能问题，这称为浸泡测试。

**43。耐久性测试**:耐久性测试是一种非功能性测试。它也被称为浸泡测试。在这种情况下，应用程序会在相当长的时间内承受相当大的负载，以检查其行为和性能。

**44。稳定性测试**:稳定性测试是一种测试方法，用于检查应用程序在特定状态或压力下执行所需操作的能力。它是一种非功能性测试，用于检测性能缺陷。

稳定性测试有时也称为耐久性测试。这是一种可选的测试技术，用于验证应用程序是否可以在特定的时间段内，在大量用户和压力下不间断地运行。它还检查内存泄漏或其他降低应用程序稳定性的问题。

**45。可伸缩性测试:**可伸缩性测试是一种非功能性测试。这是为了确定测试中的应用程序如何随着工作负载的增加而扩展。

**46。容量测试**:验证系统/应用能够处理大量数据

**47。健壮性测试**:健壮性测试是一种用来验证应用程序健壮性的测试。

**48。漏洞测试**:漏洞测试是识别应用程序中的漏洞或弱点的过程。

**49。临时测试**:临时测试与正式测试完全相反。这是一种非正式的测试类型。在即席测试中，测试人员随机测试应用程序，而不遵循任何文档和测试设计技术。如果测试人员对被测应用程序的了解非常多，那么就主要执行这种测试。测试人员随机测试应用程序，没有任何测试用例或任何业务需求文档。

50。探索性测试:通常，这个过程会由领域专家来执行。他们仅仅通过探索应用程序的功能来执行测试，而不了解需求。

51。重新测试:确保在早期构建中发现并发布的缺陷在当前构建中得到修复。比方说，Build 1.0 发布了。测试团队发现了一些缺陷(缺陷 Id 1.0.1，1.0.2)并发布。Build 1.1 发布了，现在测试这个 Build 中的缺陷 1.0.1 和 1.0.2 正在重新测试。

**52。回归测试**:在修改后，对已经测试过的程序进行重复测试，以发现由于被测试软件或其他相关或不相关软件组件的变化而引入或暴露的任何缺陷。

53。冒烟测试:冒烟测试是为了确定我们从开发团队那里收到的构建是否是可测试的。它也被称为“第 0 天”检查。这是在“构建级别”完成的。当关键特性不起作用或者关键错误还没有被修复时，不要浪费测试时间来简单地测试整个应用程序。

54。健全性测试:健全性测试是在发布阶段进行的，目的是检查应用程序的主要功能，而不需要深入。它也被称为回归测试的子集。它是在“发布级别”完成的。有时由于发布时间的限制，无法对构建进行严格的回归测试，健全性测试通过检查主要功能来完成这一部分。

**55。动态测试**:动态测试涉及代码的执行。它用预期的结果验证输出

56。静态测试:静态测试包括审查文档以在 SDLC 的早期阶段识别缺陷。

**57。猴子测试**:故意对应用程序执行异常动作，以验证应用程序的稳定性。

**58。大猩猩测试**:大猩猩测试是由测试人员完成的，有时候开发人员也会和测试人员联手。它包括反复测试系统，以测试系统的健壮性。

59。可用性测试:验证应用程序是否用户友好，最终用户使用起来是否舒适。该测试的主要焦点是检查最终用户是否能够容易地理解和操作该应用程序。一个应用程序应该是自我探索的，不需要培训就可以操作。

60。易访问性测试:易访问性测试是可用性测试的一个子集。它旨在发现残障人士(如视觉障碍、身体障碍、听力障碍、认知障碍、学习障碍)使用系统的难易程度。

61。兼容性 **测试**:部署并检查应用程序在不同的环境组件组合中是否如预期的那样工作。

62。配置测试:配置测试是用每一种受支持的硬件和软件配置测试应用程序的过程，以确定应用程序是否可以正常工作。

63。本地化测试:本地化是通过添加本地特定组件，使全球化软件适应特定地区或语言的过程。

**64。全球化测试**:全球化是一个设计软件应用程序的过程，这样它就可以适应各种语言和地区，而无需做任何更改。

65。国际化测试–参考全球化测试

66。正面测试:确定系统应该做什么。它有助于检查应用程序是否符合需求。

**67。负面测试**:确定系统不应该做什么。它有助于从软件中发现缺陷。

68。安全测试:安全测试是确定系统是否按照预期保护数据和维护功能的过程。

> [安全测试完整指南](https://www.softwaretestingmaterial.com/security-testing-tutorial/)

69。渗透测试:渗透测试也称为笔测试。这是一种安全测试。执行它是为了评估系统的安全性。

> [渗透测试完整指南](https://www.softwaretestingmaterial.com/penetration-testing-tutorial/)

70。数据库测试:进行数据库测试是为了验证 UI 中的数据与数据库中存储的数据是否匹配。它包括检查模式、表、触发器等。数据库的。

71。Bucket Testing:Bucket Testing 是一种将应用程序的两个版本相互比较以确定哪个版本性能更好的方法。

72。A/B 测试:参考铲斗测试…

73。分割测试–参考铲斗测试…

74。可靠性测试:长时间持续对应用程序进行测试，以验证应用程序的稳定性

75。接口测试:执行接口测试是为了评估两个预期的模块之间是否能够正确地传递数据和通信。

76。并发测试:并发测试是指多个用户同时访问应用，保证系统的稳定性。这主要用于识别死锁问题。

**77。模糊测试**:模糊测试用于识别应用程序中的编码错误和安全漏洞。通过向系统输入大量随机数据，试图使系统崩溃，以确定应用程序中是否有任何问题。

78。GUI 测试:图形用户界面测试就是测试应用程序和最终用户之间的界面。主要是测试人员关心的外观元素，如字体和颜色是否符合设计规范。

79。API 测试 : API 代表应用编程接口。API 测试是软件测试的一种类型，包括使用一些工具如 SOAPUI、PostMan 来测试 API。

80。敏捷测试:敏捷测试是一种测试类型，它涉及到敏捷软件开发方法的下列原则。在这种敏捷测试中，测试贯穿于持续发展的项目的整个生命周期，而不是局限于某个特定的阶段。

81。端到端测试:端到端测试是检查软件从开始到结束的流程是否符合预期结果的测试方法。它有助于确定系统中的依赖关系，并确保在多个组件之间交互时没有数据丢失或损坏。

在进行端到端测试时，测试和验证关键特性，如数据库、其他系统、网络等之间的交互，看它们是否按照预期的结果发生。

82。恢复测试:执行恢复测试是为了确定系统崩溃或硬件故障后系统能够多快恢复。它属于非功能测试的类型。

83。基于风险的测试:识别最有可能导致故障的模块或功能，然后测试这些功能。

84。安装测试:检查应用程序是否安装成功，安装后是否按预期运行。

85。 **正式测试:**这是一个测试人员通过预先计划的程序和适当的文档来测试应用程序的过程。

86。试点测试:试点测试是公司在实时操作条件下进行的测试，目的是获得客户的信任

87。后端测试:后端测试是一种用于数据库和服务器端验证的测试技术。它通常被称为数据库测试。这样做是为了测试前端输入的数据是否存储并反映在数据库中。后端测试用于防止数据截断和丢失。

数据库测试可以是非功能性的[处理数据库的性能]，功能性的[处理后端的应用程序特性]和结构性的[处理数据库结构的测试，如表、视图等]。因此，后端测试处理的是从前端看不到的后端项目。

88。跨浏览器测试:跨浏览器测试是一种非功能性测试，帮助我们确保我们的网站或网络应用程序在各种网络浏览器中正常运行。

[阅读更多关于跨浏览器测试的信息](https://www.softwaretestingmaterial.com/what-is-cross-browser-testing/) …

89。浏览器兼容性测试:浏览器兼容性测试是测试阶段的重要组成部分。这样做是为了在多个 web 浏览器中验证应用程序。必须分配足够的资源来执行该测试。

浏览器兼容性测试中最重要的检查点是浏览器的字体外观、页眉和页脚、页面样式、日期格式、图像定位、HTML 和 CSS 验证、放大和缩小以及页面元素的对齐等等。

**90。前向兼容性测试**:前向兼容性测试是为了验证被测应用程序在软件当前版本的后续版本中是否能正常工作。

**91。向后兼容性测试**:向后兼容性测试是为了验证被测应用程序在软件当前版本的早期版本中是否正常工作。

**92。向下兼容性测试**:参考向后兼容性测试…

**93。符合性测试**:符合性测试是一种非功能性测试，用来验证软件是否符合一组定义的标准。

**94。一致性测试**:一致性测试是一种在产品发布前检查产品是否符合特定标准的测试技术。这些标准是由像 IEEE 这样的组织定义的，以确保软件是兼容的。

一致性测试功能包括以下几点:

*   它由在其领域内获得认证的外部组织执行。
*   它检查健壮的测试过程。
*   它用批准的测试过程进行测试。

**95。UI 测试**:在 UI 测试中，测试人员的目标是测试 GUI 和命令行界面(CLIs)

另外，请参考 GUI 测试…

**96。破坏性测试**:破坏性测试是一种测试技术，旨在通过持续测试直到应用程序崩溃来验证应用程序的健壮性。

**97。依赖测试**:依赖测试是一种测试技术，它检查应用程序的先决条件、初始状态以及应用程序正常运行的配置。

**98。众包测试**:众包测试是由一群专家质量保证测试人员通过一个在线平台进行的。

**99。ETL 测试** : ETL(提取、转换和加载)测试包括使从源到目的地的数据移动无效，验证源和目的地的数据计数，验证数据提取、转换，以及验证表关系。

**100。数据仓库测试**:参见 ETL 测试…

101。故障注入测试:故障注入测试是一种为了提高测试覆盖率而有意在代码中引入故障的测试技术。

**102。故障转移测试**:故障转移测试是一种测试技术，用于验证系统在服务器故障和将处理部分转移到备份系统期间分配额外资源的能力

**103。所有配对测试**:所有配对测试方法是用输入参数值的所有可能组合来测试应用程序。

**104。成对测试:**成对测试是用参数的排列组合来测试应用的一种测试方法。这样做是为了测试所有可行的离散规格组合。通过使用正常的穷举测试方法，可能无法测试完整的产品。但是通过输入的排列和组合，产品的测试是可以实现的。

例如，让我们考虑一个有 15 个输入要测试的产品，每个输入有 15 种可能的配置。因此，有一个总的 15^15 输入要测试。在这种情况下，完整的测试是不可能的，我们必须选择输入的组合。

这里我将总结不同类型的软件测试类型。如果你喜欢这个帖子，请分享给你的朋友。

在这里，我精心挑选了几个帖子，可以帮助你了解更多与面试相关的东西:

*   [手动测试教程](https://www.softwaretestingmaterial.com/manual-testing-tutorial/)
*   [敏捷教程](https://www.softwaretestingmaterial.com/category/agile/)
*   [人工测试面试问题](https://www.softwaretestingmaterial.com/100-software-testing-interview-questions/)
*   [敏捷面试问题](https://www.softwaretestingmaterial.com/agile-testing-interview-questions/)
*   [你为什么选择软件测试作为职业](https://www.softwaretestingmaterial.com/choose-software-testing-as-a-career/)
*   [一般面试问题](https://www.softwaretestingmaterial.com/6-important-interview-questions/)

如果您还有任何问题，请随时通过评论提问。如果你觉得这篇文章有用，请在社交网络上与你的朋友分享。